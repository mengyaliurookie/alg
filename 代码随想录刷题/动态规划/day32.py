
# 509. 斐波那契数
topic="""
斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列 。该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。也就是：

F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
给定 n ，请计算 F(n) 。

 

示例 1：

输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
示例 2：

输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
示例 3：

输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
"""

class Solution:
    def fib(self, n: int) -> int:
        fn1 = 0
        fn2 = 1
        if n == 0: return fn1
        if n == 1: return fn2
        for i in range(n - 1):
            tem = fn2
            fn2 = fn1 + fn2
            fn1 = tem

        return fn2


# 70. 爬楼梯
topic="""
假设你正在爬楼梯。需要 n 阶你才能到达楼顶。

每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

 

示例 1：

输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
示例 2：

输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
"""

class Solution:
    def climbStairs(self, n: int) -> int:
        # 对于第n个台阶，有两种方法可以到达，从n-1爬1，从n-2爬2
        # 所以dp数组表示
        # dp[n]表示到达第n个台阶你有多少种方法
        # 递推公式是dp[n]=dp[n-1]+dp[n-2]
        # 边界条件是
        # dp[1]
        a, b = 1, 1
        for i in range(1, n):
            a, b = b, a + b
        return b


# 746. 使用最小花费爬楼梯
topic="""
给你一个整数数组 cost ，其中 cost[i] 是从楼梯第 i 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 0 或下标为 1 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

 

示例 1：

输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
示例 2：

输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
"""

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 到达第n个台阶，可以从n-1爬一步到达，也可以直接从n-2爬两步到达
        # 所以dp[n]表示的是到达第n个台阶的最低花费
        # dp[n]=min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2])
        # 边界条件
        # 当n等于0或者等于1时
        n=len(cost)
        dp=[0 for _ in range(n+1)]
        for i in range(2,n+1):
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        # print(dp)
        return dp[-1]

class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        # 到达第n个台阶，可以从n-1爬一步到达，也可以直接从n-2爬两步到达
        # 所以dp[n]表示的是到达第n个台阶的最低花费
        # dp[n]=min(dp[n-1]+cost[n-1],dp[n-2]+cost[n-2])
        # 边界条件
        # 当n等于0或者等于1时
        n=len(cost)
        a,b=0,0
        for i in range(2,n+1):
            tem=min(a+cost[i-1],b+cost[i-2])
            b=a
            a=tem
        # print(dp)
        return a


# 62.不同路径
topic="""
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

 输入：m = 3, n = 7
输出：28
示例 2：

输入：m = 3, n = 2
输出：3
解释：
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向下 -> 向下
2. 向下 -> 向下 -> 向右
3. 向下 -> 向右 -> 向下
示例 3：

输入：m = 7, n = 3
输出：28
示例 4：

输入：m = 3, n = 3
输出：6
"""
















